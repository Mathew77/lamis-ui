"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var easingFunctions = {
    linear: function (n) { return n; },
    elastic: function (n) { return n * (33 * n * n * n * n - 106 * n * n * n + 126 * n * n - 67 * n + 15); },
    inExpo: function (n) { return Math.pow(2, 10 * (n - 1)); },
};
function useAnimationTimer(duration, delay) {
    if (duration === void 0) { duration = 1000; }
    if (delay === void 0) { delay = 0; }
    var _a = react_1.useState(0), elapsed = _a[0], setTime = _a[1];
    react_1.useEffect(function () {
        var animationFrame;
        var timerStop;
        var start;
        // Function to be executed on each animation frame
        function onFrame() {
            setTime(Date.now() - start);
            loop();
        }
        // Call onFrame() on next animation frame
        function loop() {
            animationFrame = requestAnimationFrame(onFrame);
        }
        function onStart() {
            // Set a timeout to stop things when duration time elapses
            timerStop = setTimeout(function () {
                cancelAnimationFrame(animationFrame);
                setTime(Date.now() - start);
            }, duration);
            // Start the loop
            start = Date.now();
            loop();
        }
        // Start after specified delay (defaults to 0)
        var timerDelay = setTimeout(onStart, delay);
        // Clean things up
        return function () {
            clearTimeout(timerStop);
            clearTimeout(timerDelay);
            cancelAnimationFrame(animationFrame);
        };
    }, [duration, delay]); // Only re-run effect if duration or delay changes
    return elapsed;
}
function useAnimation(easing, duration, delay) {
    if (easing === void 0) { easing = 'linear'; }
    if (duration === void 0) { duration = 500; }
    if (delay === void 0) { delay = 0; }
    // The useAnimationTimer hook calls useState every animation frame ...
    // ... giving us elapsed time and causing a rerender as frequently ...
    // ... as possible for a smooth animation.
    var elapsed = useAnimationTimer(duration, delay);
    // Amount of specified duration elapsed on a scale from 0 - 1
    var n = Math.min(1, elapsed / duration);
    // Return altered value based on our specified easing function
    return typeof easing === 'string' ? easingFunctions[easing](n) : easing(n);
}
exports.useAnimation = useAnimation;
