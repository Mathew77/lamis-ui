var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
import { useReducer, useCallback } from 'react';
// Our reducer function to handle state changes based on action
function reducer(state, action) {
    var past = state.past, present = state.present, future = state.future;
    switch (action.type) {
        case 'UNDO':
            var previous = past[past.length - 1];
            var newPast = past.slice(0, past.length - 1);
            return {
                past: newPast,
                present: previous,
                future: __spreadArrays([present], future),
            };
        case 'REDO':
            var next = future[0];
            var newFuture = future.slice(1);
            return {
                past: __spreadArrays(past, [present]),
                present: next,
                future: newFuture,
            };
        case 'SET':
            var newPresent = action.newPresent;
            if (newPresent === present) {
                return state;
            }
            return {
                past: __spreadArrays(past, [present]),
                present: newPresent,
                future: [],
            };
        case 'CLEAR':
            var initialPresent = action.initialPresent;
            return {
                past: [],
                future: [],
                present: initialPresent,
            };
    }
}
export function useHistory(initialPresent) {
    var _a = useReducer(reducer, {
        // Array of previous state values updated each time we push a new state
        past: [],
        present: initialPresent,
        // Will contain "future" state values if we undo (so we can redo)
        future: [],
    }), state = _a[0], dispatch = _a[1];
    var canUndo = state.past.length !== 0;
    var canRedo = state.future.length !== 0;
    // Setup our callback functions
    // We memoize with useCallback to prevent unecessary re-renders
    var undo = useCallback(function () {
        if (canUndo) {
            dispatch({ type: 'UNDO' });
        }
    }, [canUndo, dispatch]);
    var redo = useCallback(function () {
        if (canRedo) {
            dispatch({ type: 'REDO' });
        }
    }, [canRedo, dispatch]);
    var set = useCallback(function (newPresent) { return dispatch({ type: 'SET', newPresent: newPresent }); }, [dispatch]);
    var clear = useCallback(function () { return dispatch({ type: 'CLEAR', initialPresent: initialPresent }); }, [dispatch, initialPresent]);
    // If needed we could also return past and future state
    return { state: state.present, set: set, undo: undo, redo: redo, clear: clear, canUndo: canUndo, canRedo: canRedo };
}
